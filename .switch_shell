# Adam's .switch_shell
#
# Try switch shell if we're interactive, aiming for safety, but
# not so much that we end up hogging memory.
#
# $Id$
#
# Usage:
#
# . /path/to/.switch_shell [-d] [ /path/to/new_shell [ <new shell options> ]
#    -d turns on debugging

if [ "$1" = '-d' ]; then
  debug=yes
  shift
fi

if [ -n "$1" ]; then
  myshell="$1"
  shift
else
  # Sensible default shell to switch to.
  myshell=`which zsh` 2>/dev/null
fi

# Very cute trick from Bart Schaefer which is a valid alternative approach
#eval `$myshell -f -c "echo exec $myshell" || echo :` '"$@"'

switch_shell_safely () {
  # we do this rather than exec() just in case $myshell fails to run.
  [ -n "$debug" ] && echo "Switching to $myshell safely ..."
  "$myshell" "$@" && exit
}

switch_shell_dangerously () {
  [ -n "$debug" ] && echo "Switching to $myshell dangerously ..."
  exec "$myshell" "$@"
}

switch_shell () {
  if [ ! -x $myshell ]; then
    [ -n "$debug" ] && echo "$myshell not executable; aborting switch."
    return
  fi

  if [ -n "$NO_SWITCH" ]; then
    [ -n "$debug" ] && echo 'Shell switching disabled by $NO_SWITCH; aborting.'
    return
  fi

  case "$SHLVL" in
    1) # login shell, be careful
       switch_shell_safely "$@"
       ;;
    *) # other shell, be risky and save memory
       switch_shell_dangerously "$@"
       ;;
  esac
}

# only switch if we're interactive
case "$-" in
  *i*) switch_shell "$@"
       ;;
esac

