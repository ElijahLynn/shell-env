#!/usr/bin/env perl

use strict;
use warnings;

use Date::Manip 'Delta_Format';
use File::Basename;
use Getopt::Long;
use POSIX 'strftime';

my %opts;
Getopt::Long::Configure('bundling');
GetOptions(
  \%opts,
  'last|l', 'idle|i', 'human|h',
  'tty|t', 'x11idle|x',
  'debug|d', 'help'
) or usage();
usage() if $opts{help};

use constant NEED_ON_SINCE => 1;
use constant NEED_IDLE     => 2;
use constant NEED_LOGIN    => 3;

sub usage {
  my $me = basename $0;
  die <<EOUSAGE;
Usage: $me [options] [username[\@host]]

Finds the session with the smallest idle time corresponding to the
specified user and by default outputs the number of seconds idle.

Options:
  -l, --last     Output time last active as seconds since epoch
  -t, --tty      Output corresponding tty
  -i, --idle     with -l/-t: show time idle in addition to other output
  -h, --human    Output idle/last active time(s) in human-readable format
  -x, --x11idle  Use data from x11idle if available (spots mouse movement)
  -d, --debug
      --help
EOUSAGE
}

my $who = shift || scalar(getpwuid $<);

my $x11idle = $ENV{DISPLAY} ? `x11idle 2>&1` : '';
if (defined $x11idle) {
  chomp $x11idle;
}
else {
  $x11idle = '';
}

open(FINGER, "finger -l -m $who|")
  or die "open(finger -l -m $who|) failed: $!\n";

my ($least_idle_secs, $least_idle_tty, $tty, $from);

# The format of finger(1)'s output is such that an idle time line
# always follows an 'On since' line.  If the expected idle time line
# is absent, it indicates that the corresponding session is not idle
# at all.
#
# We aim to find the session with the *least* idle time.
my $state = NEED_LOGIN;
while (<FINGER>) {
  if ($state == NEED_LOGIN) {
    if (/^Login( name)?:/i) {
      debug("Got login line\n");
      $state = NEED_ON_SINCE;
      undef $tty;
      undef $from;
    }
    next;
  }

  if ($state == NEED_ON_SINCE) {
    $state = NEED_IDLE if s/\bon since.*? on (\S+)\s*?(?: from (\S+))?//i;
    ($tty, $from) = ($1, $2);
    $tty ||= '';
    $from ||= '';
    debug("tty [$tty] from [$from]\n");
    debug("Merged line; redoing\n"), redo if /\bidle\b/;
    next;
  }

  if ($state == NEED_IDLE) {
    if (s/\bidle(\s+time)?\b//i) {
      my $secs = parse_idle_time($_);

      # Prefer pts terminals to tty7, since more useful.
      if ($from =~ /^:\d+(\.\d)?$/) {
        $secs += 1;
        debug("Upped idle time for $from to $secs\n");
      }
      else {
        debug("Idle time for $from is $secs\n");
      }

      if (! defined $least_idle_secs) {
        $least_idle_secs = $secs;
        $least_idle_tty  = $tty;
        debug("Least idle now $secs seconds\n");
      }
      elsif ($secs < $least_idle_secs) {
        debug("Found smaller idle time of $secs seconds\n");
        $least_idle_secs = $secs;
        $least_idle_tty  = $tty;
      }
      $state = NEED_ON_SINCE;
      next;
    }
    
    debug("Got:\n$_\ninstead of idle line; assuming not idle at all.\n");
    $least_idle_secs = 0;
    $least_idle_tty  = $tty;
    $state = NEED_ON_SINCE;
    last;
  }
}

if ($state == NEED_IDLE) {
  debug("Finished expecting an idle line; assuming not idle at all.\n");
  $least_idle_secs = 0;
  $least_idle_tty  = $tty;
}

if ($state == NEED_LOGIN) {
  die "Didn't get login line.\n";
}

if ($opts{x11idle} and $x11idle =~ /^\d+$/) {
  $x11idle = int($x11idle / 1000);
  # Give a slight preference to tty-based idle times,
  # since they're more informative.
  if ($x11idle + 1 < $least_idle_secs) {
    $least_idle_secs = $x11idle;
    $least_idle_tty  = $ENV{DISPLAY} || 'x11';
  }
}

sub parse_idle_time {
  my ($text) = @_;
  $_ = $text;

  chomp;
  s/^\s+//;
  
  my $secs;
  $secs += $1 * 3600 * 24 if s/(\d+) days?\s+//i;
  $secs += $1 * 3600      if s/(\d+) hours?\s+//i;
  $secs += $1 *   60      if s/(\d+) min(ute)?s?\s+//i;
  $secs += $1             if s/(\d+) sec(ond)?s?\s+//i;

  return $secs;
}

close(FINGER);

if (! defined $least_idle_secs) {
  # Didn't get any idle time; not logged on.
  exit 1;
}

sub get_time_idle {
  return $least_idle_secs unless $opts{human};

  my @units = Delta_Format(
    $least_idle_secs . 'S',
    0,
    map "%${_}v", qw{y M w d h m s},
  );
  
  my $i = 0;
  my @out;
  for my $unit (qw{year month week day hour minute second}) {
    if (my $val = $units[$i]) {
      my $out = "$val $unit";
      $out   .= "s" if $val != 1;
      debug("adding $out\n");
      push @out, $out;
    }
    $i++;
  }
  @out = ('0 seconds') if @out == 0;
    
  return "@out idle", 
}

my %out;
$out{'idle'} = get_time_idle();
$out{'last'} = time() - $least_idle_secs;
$out{'last'} = "last active at " . scalar localtime($out{'last'})
  if $opts{human};
$out{'tty'}  = $opts{human} ? "on $least_idle_tty" : $least_idle_tty;

$opts{'idle'} = 1 unless ! $opts{idle} && ($opts{'last'} || $opts{'tty'});
my @out;
foreach (qw{idle tty last}) {
  push @out, $out{$_} if $opts{$_};
}

my $out = join(" ", @out);
$out =~ s/ last active/,$&/;
print "$out\n";

sub debug {
  warn @_ if $opts{debug};
}
