#!/usr/bin/env perl

use strict;
use warnings;

use Date::Manip 'Delta_Format';
use File::Basename;
use Getopt::Long;
use POSIX 'strftime';

Getopt::Long::Configure('bundling');

my %opts = ( verbosity => 1 );

GetOptions(
  \%opts,
  'last|l', 'idle|i', 'human|h',
  'tty|t', 'x11idle|x',
  'verbosity|verbose|v:+',
  'help|?'
) or usage();
usage() if $opts{help};

use constant NEED_ON_SINCE => 1;
use constant NEED_IDLE     => 2;
use constant NEED_LOGIN    => 3;

sub usage {
  my $me = basename $0;
  die <<EOUSAGE;
Usage: $me [options] [username[\@host]]

Finds the session with the smallest idle time corresponding to the
specified user and by default outputs the number of seconds idle.

Options:
  -l, --last        Output time last active as seconds since epoch
  -t, --tty         Output corresponding tty
  -i, --idle        with -l/-t: show time idle in addition to other output
  -h, --human       Output idle/last active time(s) in human-readable format
  -x, --x11idle     Use data from x11idle if available (spots mouse movement)
  -v, --verbose[=N] Increase [specify] verbosity (defaults to 1)
  -?, --help
EOUSAGE
}

my $who = shift || scalar(getpwuid $<);

my $x11idle = $ENV{DISPLAY} ? `x11idle 2>&1` : '';
if (defined $x11idle) {
  chomp $x11idle;
}
else {
  $x11idle = '';
}

my $cmd = "finger -l -m $who";
debug(2, "Command: $cmd");
open(FINGER, "$cmd|")
  or die "open($cmd|) failed: $!\n";

my ($least_idle_secs, $least_idle_tty, $tty, $from);

# The format of finger(1)'s output is such that an idle time line
# always follows an 'On since' line.  If the expected idle time line
# is absent, it indicates that the corresponding session is not idle
# at all.
#
# We aim to find the session with the *least* idle time.
my $state = NEED_LOGIN;
while (<FINGER>) {
  chomp;
  debug(3, "Parsing line [$_]");

  if ($state == NEED_LOGIN) {
    if (/^Login( name)?:/i) {
      debug(3, "    Got login line");
      $state = NEED_ON_SINCE;
      undef $tty;
      undef $from;
    }
    else {
      debug(4, "  . Looking for login; skipping line");
    }
    next;
  }

  if ($state == NEED_ON_SINCE) {
    debug(5, "  NEED_ON_SINCE");
    if (s!\bon since.*? on (tty\d+|pts/\d+|:\d\d?),?\s*?(?: from (\S+))?!!i) {
      $state = NEED_IDLE;
      ($tty, $from) = ($1, $2);
      $tty ||= '';
      $from ||= '';
      debug(3, "    tty [$tty] from [$from]");
      if (/\bidle\b/) {
        debug(3, "  < Merged line; redoing as [$_]");
        redo;
      }
    }
    else {
      debug(4, "  . Looking for 'on since'; skipping line");
    }
    next;
  }

  if ($state == NEED_IDLE) {
    debug(5, "  NEED_IDLE");
    if (! /On since/ && s/\bidle(\s+time)?\b//i) {
      my $secs = parse_idle_time($_);

      # Prefer pts terminals to tty7, since more useful.
      if ($tty =~ /^:\d+(\.\d)?$/) {
        $secs += 1;
        debug(2, "  - Upped idle time for $tty to $secs");
      }
      else {
        debug(2, "  - Idle time for $tty is $secs");
      }

      if (! defined $least_idle_secs) {
        $least_idle_secs = $secs;
        $least_idle_tty  = $tty;
        debug(2, "  = Least idle now $secs seconds");
      }
      elsif ($secs < $least_idle_secs) {
        debug(2, "  = Found smaller idle time of $secs seconds");
        $least_idle_secs = $secs;
        $least_idle_tty  = $tty;
      }
      $state = NEED_ON_SINCE;
      next;
    }

    # On SUSE, :0 style lines don't display idle time.
    # FIXME: does this break Fedora?
    if ($tty =~ /^:\d+(\.\d)?$/) {
      debug(3, "    ignoring $tty line");
      $state = NEED_ON_SINCE;
    }
    else {
      debug(2, "  ! Didn't get idle time on continuation line; assuming not idle at all.");
      $least_idle_secs = 0;
      $least_idle_tty  = $tty;
      $state = NEED_ON_SINCE;
      last;
    }
  }
}

if ($state == NEED_IDLE) {
  debug(2, "Finished expecting an idle line; assuming not idle at all.");
  $least_idle_secs = 0;
  $least_idle_tty  = $tty;
}

if ($state == NEED_LOGIN) {
  die "Didn't get login line.\n";
}

if ($opts{x11idle} and $x11idle =~ /^\d+$/) {
  $x11idle = int($x11idle / 1000);
  # Give a slight preference to tty-based idle times,
  # since they're more informative.
  if ($x11idle + 1 < $least_idle_secs) {
    $least_idle_secs = $x11idle;
    $least_idle_tty  = $ENV{DISPLAY} || 'x11';
  }
}

sub parse_idle_time {
  my ($text) = @_;
  $_ = $text;

  s/^\s+//;
  
  my $secs = 0;
  $secs += $1 * 3600 * 24 if s/(\d+) days?\s+//i;
  $secs += $1 * 3600      if s/(\d+) hours?\s+//i;
  $secs += $1 *   60      if s/(\d+) min(ute)?s?\s+//i;

  if (/(\d?\d):(\d\d)?/) {
    # SUSE style, only gives to the minute, not to the second :-(
    # On since Mon Jan 18 11:50 (GMT) on pts/12, idle 6 days 4:33
    # On since Mon Jan 18 11:50 (GMT) on pts/13, idle 6:08
    debug(4, "    SUSE style: $1 hours $2 seconds");
    $secs += $1 * 3600 + $2 * 60;
  }
  elsif (s/(\d+) sec(ond)?s?\s+//i) {
    # Fedora style:
    #   15 minutes 49 seconds idle
    debug(4, "    Fedora style: $1 seconds");
    $secs += $1;
  }
  else {
    die "Failed to parse idle line [$_]\n";
  }

  return $secs;
}

close(FINGER);

if (! defined $least_idle_secs) {
  # Didn't get any idle time; not logged on.
  exit 1;
}

sub get_time_idle {
  return $least_idle_secs unless $opts{human};

  my @units = Delta_Format(
    $least_idle_secs . 'S',
    0,
    map "%${_}v", qw{y M w d h m s},
  );
  
  my $i = 0;
  my @out;
  for my $unit (qw{year month week day hour minute second}) {
    if (my $val = $units[$i]) {
      my $out = "$val $unit";
      $out   .= "s" if $val != 1;
      debug(3, "adding $out");
      push @out, $out;
    }
    $i++;
  }
  @out = ('0 seconds') if @out == 0;
    
  return "@out idle", 
}

my %out;
$out{'idle'} = get_time_idle();
$out{'last'} = time() - $least_idle_secs;
$out{'last'} = "last active at " . scalar localtime($out{'last'})
  if $opts{human};
$out{'tty'}  = $opts{human} ? "on $least_idle_tty" : $least_idle_tty;

$opts{'idle'} = 1 unless ! $opts{idle} && ($opts{'last'} || $opts{'tty'});
my @out;
foreach (qw{idle tty last}) {
  push @out, $out{$_} if $opts{$_};
}

my $out = join(" ", @out);
$out =~ s/ last active/,$&/;
print "$out\n";

sub debug {
  my $level = shift;
  warn @_, "\n" if $opts{verbosity} >= $level;
}
