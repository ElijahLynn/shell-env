#!/usr/bin/env perl

use strict;
use warnings;

use Date::Manip 'Delta_Format';
use File::Basename;
use Getopt::Long;
use POSIX 'strftime';

my %opts;
Getopt::Long::Configure('bundling');
GetOptions(
  \%opts,
  'last|l', 'idle|i', 'human|h',
  'tty|t', 'x11idle|x',
  'debug|d', 'help|?'
) or usage();
usage() if $opts{help};

use constant NEED_ON_SINCE => 1;
use constant NEED_IDLE     => 2;
use constant NEED_LOGIN    => 3;

sub usage {
  my $me = basename $0;
  die <<EOUSAGE;
Usage: $me [options] [username[\@host]]

Finds the session with the smallest idle time corresponding to the
specified user and by default outputs the number of seconds idle.

Options:
  -l, --last     Output time last active as seconds since epoch
  -t, --tty      Output corresponding tty
  -i, --idle     with -l/-t: show time idle in addition to other output
  -h, --human    Output idle/last active time(s) in human-readable format
  -x, --x11idle  Use data from x11idle if available (spots mouse movement)
  -d, --debug
  -?, --help
EOUSAGE
}

my $who = shift || scalar(getpwuid $<);

my $x11idle = $ENV{DISPLAY} ? `x11idle 2>&1` : '';
if (defined $x11idle) {
  chomp $x11idle;
}
else {
  $x11idle = '';
}

my $cmd = "finger -l -m $who";
debug("Command: $cmd\n");
open(FINGER, "$cmd|")
  or die "open($cmd|) failed: $!\n";

my ($least_idle_secs, $least_idle_tty, $tty, $from);

# The format of finger(1)'s output is such that an idle time line
# always follows an 'On since' line.  If the expected idle time line
# is absent, it indicates that the corresponding session is not idle
# at all.
#
# We aim to find the session with the *least* idle time.
my $state = NEED_LOGIN;
while (<FINGER>) {
  if ($state == NEED_LOGIN) {
    if (/^Login( name)?:/i) {
      debug("Got login line\n");
      $state = NEED_ON_SINCE;
      undef $tty;
      undef $from;
    }
    else {
      debug("Got useless line [$_] whilst looking for login\n");
    }
    next;
  }

  if ($state == NEED_ON_SINCE) {
    if (s!\bon since.*? on (tty\d+|pts/\d+|:\d\d?),?\s*?(?: from (\S+))?!!i) {
      $state = NEED_IDLE;
      ($tty, $from) = ($1, $2);
      $tty ||= '';
      $from ||= '';
      debug("tty [$tty] from [$from]\n");
      debug("Merged line; redoing\n"), redo if /\bidle\b/;
    }
    else {
      debug("Got useless line [$_] whilst looking for 'on since'\n");
    }
    next;
  }

  if ($state == NEED_IDLE) {
    if (s/\bidle(\s+time)?\b//i) {
      my $secs = parse_idle_time($_);

      # Prefer pts terminals to tty7, since more useful.
      if ($tty =~ /^:\d+(\.\d)?$/) {
        $secs += 1;
        debug("Upped idle time for $tty to $secs\n");
      }
      else {
        debug("Idle time for $tty is $secs\n");
      }

      if (! defined $least_idle_secs) {
        $least_idle_secs = $secs;
        $least_idle_tty  = $tty;
        debug("Least idle now $secs seconds\n");
      }
      elsif ($secs < $least_idle_secs) {
        debug("Found smaller idle time of $secs seconds\n");
        $least_idle_secs = $secs;
        $least_idle_tty  = $tty;
      }
      $state = NEED_ON_SINCE;
      next;
    }
    
    debug("Got:\n$_\ninstead of idle line; assuming not idle at all.\n");
    $least_idle_secs = 0;
    $least_idle_tty  = $tty;
    $state = NEED_ON_SINCE;
    last;
  }
}

if ($state == NEED_IDLE) {
  debug("Finished expecting an idle line; assuming not idle at all.\n");
  $least_idle_secs = 0;
  $least_idle_tty  = $tty;
}

if ($state == NEED_LOGIN) {
  die "Didn't get login line.\n";
}

if ($opts{x11idle} and $x11idle =~ /^\d+$/) {
  $x11idle = int($x11idle / 1000);
  # Give a slight preference to tty-based idle times,
  # since they're more informative.
  if ($x11idle + 1 < $least_idle_secs) {
    $least_idle_secs = $x11idle;
    $least_idle_tty  = $ENV{DISPLAY} || 'x11';
  }
}

sub parse_idle_time {
  my ($text) = @_;
  $_ = $text;

  chomp;
  s/^\s+//;
  
  my $secs = 0;
  $secs += $1 * 3600 * 24 if s/(\d+) days?\s+//i;
  $secs += $1 * 3600      if s/(\d+) hours?\s+//i;
  $secs += $1 *   60      if s/(\d+) min(ute)?s?\s+//i;

  if (/ (\d?\d):(\d\d)(,|$)/) {
    # SUSE style, only gives to the minute, not to the second :-(
    # On since Mon Jan 18 11:50 (GMT) on pts/12, idle 6 days 4:33
    # On since Mon Jan 18 11:50 (GMT) on pts/13, idle 6:08
    $secs += $1 * 3600 + $2 * 60;
  }
  elsif (s/(\d+) sec(ond)?s?\s+//i) {
    # Fedora style:
    #   15 minutes 49 seconds idle
    $secs += $1;
  }

  return $secs;
}

close(FINGER);

if (! defined $least_idle_secs) {
  # Didn't get any idle time; not logged on.
  exit 1;
}

sub get_time_idle {
  return $least_idle_secs unless $opts{human};

  my @units = Delta_Format(
    $least_idle_secs . 'S',
    0,
    map "%${_}v", qw{y M w d h m s},
  );
  
  my $i = 0;
  my @out;
  for my $unit (qw{year month week day hour minute second}) {
    if (my $val = $units[$i]) {
      my $out = "$val $unit";
      $out   .= "s" if $val != 1;
      debug("adding $out\n");
      push @out, $out;
    }
    $i++;
  }
  @out = ('0 seconds') if @out == 0;
    
  return "@out idle", 
}

my %out;
$out{'idle'} = get_time_idle();
$out{'last'} = time() - $least_idle_secs;
$out{'last'} = "last active at " . scalar localtime($out{'last'})
  if $opts{human};
$out{'tty'}  = $opts{human} ? "on $least_idle_tty" : $least_idle_tty;

$opts{'idle'} = 1 unless ! $opts{idle} && ($opts{'last'} || $opts{'tty'});
my @out;
foreach (qw{idle tty last}) {
  push @out, $out{$_} if $opts{$_};
}

my $out = join(" ", @out);
$out =~ s/ last active/,$&/;
print "$out\n";

sub debug {
  warn @_ if $opts{debug};
}
