#!/usr/bin/perl
#
# Run a command with a timeout.  Optionally send a signal and/or run a
# command on timeout.  Exits with the exit status of the command, or 254
# if timeout happened first.

use strict;
use warnings;

use Config;
use Getopt::Long qw(:config pass_through);
use POSIX qw(:sys_wait_h);

sub debug {
#  warn @_, "\n";
}

(my $ME = $0) =~ s,.*/,,;

my %opts;
GetOptions(
  \%opts,
  'help|h',
  'signal|s=s', 'command|c=s', 'kill|k',
) or usage();
usage() if @ARGV == 0 or $opts{help};

sub usage {
  warn @_, "\n" if @_;

  die <<EOUSAGE;
Usage: $ME [options] TIMEOUT COMMAND ARGS
Timeout is in seconds.
Options:
  -h, --help               Show this help
  -k, --kill               On timeout, send TERM signal then KILL if needed
  -s, --signal=SIG, -SIG   On timeout, send signal SIG (e.g. 9 or KILL)
  -c, --command=CMD        On timeout, run command 
EOUSAGE
}

my $DOUBLE_KILL = 'double-kill';
my $signal = get_signal();
debug("May use signal $signal") if $signal;

usage() unless @ARGV >= 2;
my ($timeout, $command, @args) = @ARGV;

my $pid = fork();
if (! $pid) {
  # child
  exec $command, @args;
}

# parent
debug("child pid is $pid");

$SIG{ALRM} = sub {
  debug("Timed out after $timeout seconds");
  if (defined $signal && defined $pid) {
    debug("Sending signal $signal to pid $pid");
    kill $signal, $pid;
  }
  if ($opts{kill}) {
    waitpid($pid, WNOHANG); # reap zombie
    if (getpgrp($pid) > 0) {
      debug("pid $pid still exists; sleeping 3 ...");
      sleep 3;
      if (getpgrp($pid) > 0) {
        debug("pid $pid STILL exists; sending KILL to pid $pid");
        kill 'KILL', $pid;
      }
    }
  }
  system($opts{command}) if defined $opts{command};
  exit 254;
};
alarm $timeout;
debug("alarm set");

wait;
debug("wait finished, \$? == $?");

exit $? >> 8;

# Which signal to send on timeout?
sub get_signal {
  # Is -KILL or -9 syntax being used?
  my $short_signal = $ARGV[0] =~ /^-(.+)/ ? $1 : undef;
  my $count = 0;
  foreach my $mode ($short_signal, $opts{signal}, $opts{kill}) {
    $count++ if defined $mode;
  }
  usage("Cannot specify more than one of --signal, -SIG, and --kill\n")
    if $count > 1;

  return 15 if $opts{kill};

  shift @ARGV if $short_signal;

  return canonise_signal(defined($short_signal) ? $short_signal : $opts{signal});
}

sub canonise_signal {
  my ($signal) = @_;

  return undef unless defined $signal;

  my @signals = split ' ', $Config{sig_name};
  die "$ME: BUG reading signal names" unless $signals[9] eq 'KILL';
  my %sig2num = map { $signals[$_] => $_ } 0 .. $#signals;
  my %num2sig = map { $_ => $signals[$_] } 0 .. $#signals;

  if ($signal =~ /^(\d\d?)$/ && $num2sig{$signal}) {
    return $signal;
  }
  elsif ((uc $signal) =~ /^([A-Z][A-Z12]+)$/ && exists $sig2num{uc $signal}) {
    return $sig2num{uc $signal};
  }
  else {
    die $sig2num{ZERO};
    usage("Didn't recognise weird signal '$signal'\n");
  }
}

